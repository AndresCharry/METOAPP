# -*- coding: utf-8 -*-
"""Esperemos funcione

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YRUvgu5IMhXT754Q1WqVlDz4U_7x3Zsh
"""

#Librerias__________________________________________________________________________________________________________________
import matplotlib.patches as patches
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d.axes3d import Axes3D
import math
import random
from shapely.geometry import Polygon
import pandas as pd
import random as rm
from random import randint

"""# Funciones"""

def polygon_area(vertices):
    num_vert = len(vertices)
    sum1 = 0; sum2 = 0
    for i in range (0,num_vert-1):
        sum1 = sum1 + vertices[i][0]*vertices[i+1][1]
        sum2 = sum2 + vertices[i][1]*vertices[i+1][0]
    sum1 = sum1 + vertices[num_vert-1][0]*vertices[0][1]
    sum2 = sum2 + vertices[0][0]*vertices[num_vert-1][1]
    area = abs(sum1-sum2)/2
    return area

def vert_polig(lat,lon):
    polig = []
    for i in range (0,len(lat)):
        v = [lat[i],lon[i]]
        polig.append(v)
    return polig

def haversine(lat1, lon1, lat2, lon2):
    rad=math.pi/180
    dlat=lat2-lat1
    dlon=lon2-lon1
    R=6372.795477598
    a=(math.sin(rad*dlat/2))**2 + math.cos(rad*lat1)*math.cos(rad*lat2)*(math.sin(rad*dlon/2))**2
    distancia=2*R*math.asin(math.sqrt(a))
    return distancia

def distancias_angulos(lat,lon):
    distancias = []; angulos = []
    for i in range (0,len(lat)):
        pos = i
        if pos+1 < len(lat):
            d = haversine(lat[pos], lon[pos], lat[pos+1], lon[pos+1])
            numerador = (lat[pos+1]-lat[i])
            denominador = (lon[pos+1]-lon[i])
            ang = np.arctan((lat[pos+1]-lat[i])/(lon[pos+1]-lon[i]))
            if numerador>0 and denominador==0:
                ang = np.pi/2
            elif numerador>0 and denominador<0:
                ang = ang + np.pi
            elif numerador==0 and denominador<0:
                ang = np.pi
            elif numerador<0 and denominador<0:
                ang = ang + np.pi
            elif numerador<0 and denominador==0:
                ang = 3*np.pi/2
            elif numerador<0 and denominador>0:
                ang = ang + 2*np.pi
            elif numerador==0 and denominador>0:
                ang = 2*np.pi
            distancias.append(d*1000); angulos.append(ang)
        else: d = 0
    return angulos,distancias

def areas(distancias):
    sum = 0
    for i in distancias:
        sum = sum+i
    return sum

def markers(posxm, posym, tam,ax):
    ax.add_patch(patches.Rectangle((posxm, posym),tam,tam,edgecolor = 'black',facecolor = 'white',fill=True))
    ax.add_patch(patches.Rectangle((posxm+tam, posym),tam,tam,edgecolor = 'black',facecolor = 'black',fill=True))
    ax.add_patch(patches.Rectangle((posxm+tam, posym+tam),tam,tam,edgecolor = 'black',facecolor = 'white',fill=True))
    ax.add_patch(patches.Rectangle((posxm, posym+tam),tam,tam,edgecolor = 'black',facecolor = 'black',fill=True))

def main(num_zonas_en_campo, latitud, longitud, dron = 0, puntos_por_area = 1, pph = 10, num_markers = 0):
    """# Posiciones y campo"""

    num_zonas_en_campo = num_zonas_en_campo 
    puntos_por_area = puntos_por_area 
    pph = pph # Puntos por ha
    dron = dron
    num_markers = num_markers 
    latitud = latitud
    longitud = longitud 

    climx = []; climy = []  #  Rotación
    cpoligono = [];         # Vertices de las areas (representación)
    c_area_aparente = []; pph2 = pph*4
    polig = []; vertices_x = []; vertices_y = []
    angulos_v = []; distancias_v = [] # Angulos y distancias entre vertices

    for i in range(0,num_zonas_en_campo+1):
        climx.append(longitud[i]); climy.append(latitud[i])
        # cpolig = vert_polig(latT,lonT) # vERTICES ORIINALES
        cpolig = vert_polig(longitud[i],latitud[i])
        cpoligono.append(cpolig)
        c_area = polygon_area(cpolig)
        c_area_aparente.append(c_area)
        polyT = Polygon(cpolig)
        polig.append(polyT)
        VxT,VyT = polyT.exterior.xy
        vertices_x.append(VxT); vertices_y.append(VyT)
        angulosT,distanciasT = distancias_angulos(latitud[i],longitud[i])
        angulos_v.append(angulosT); distancias_v.append(distanciasT)

    # recreando terreno y superficie real 

    def superficie(distanciasT,angulosT):
        vertices_nuevosT = []; xT = []; yT = []
        v1T = [10,10]
        vertices_nuevosT.append(v1T)
        xT.append(v1T[0])
        yT.append(v1T[1])
        for i in range (len(angulosT)):
            x1T = v1T[0]+distanciasT[i]*np.cos(angulosT[i])
            y1T = v1T[1]+distanciasT[i]*np.sin(angulosT[i])
            v1T = [x1T,y1T]
            vertices_nuevosT.append(v1T)
            xT.append(x1T); yT.append(y1T)
        areat = polygon_area(vertices_nuevosT)
        return xT,yT,areat

    # Recreando tamaño real

    x_R = []; y_R  = []; areasreales = []

    for i in range(0,num_zonas_en_campo+1):
        xT,yT,areatT = superficie(distancias_v[i],angulos_v[i])
        x_R.append(xT); y_R.append(yT); areasreales.append(areatT)
        #print("El area del terreno es: ", areasreales[i])
    Xmax = abs(min(x_R[0]))+abs(max(x_R[0]))
    Ymax = abs(min(y_R[0]))+abs(max(y_R[0]))

    # trabajando area 1

    v_marco_x = []; v_marco_y = []
    v_marco_x_ = []; v_marco_y_ = []

    def creando_puntos(a,b,x_R,y_R,pph,vertices_x,vertices_y):
        puntos_en_area_x = []; puntos_en_area_y = []
        for i in range(a,b):
            vx_ = min(x_R[i]); vx = max(x_R[i])  ## Medidas en xy
            vy_ = min(y_R[i]); vy = max(y_R[i])
            medxA1 = abs(vx-vx_)
            medyA1 = abs(vy-vy_)

            pdx = 100/pph; pdy = 100/pph
            n_pdx = medxA1/pdx
            n_pdy = medyA1/pdy

            vx_ll = min(vertices_x[i]); vxll = max(vertices_x[i])  ## Medidas en lat lon
            vy_ll = min(vertices_y[i]); vyll = max(vertices_y[i])
            v_marco_x.append(vxll); v_marco_y.append(vyll)
            v_marco_x_.append(vx_ll); v_marco_y_.append(vy_ll)
            medxA1ll = abs(vxll-vx_ll)
            medyA1ll = abs(vyll-vy_ll)
            pdx = medxA1ll/n_pdx      # medida de distancia de puntos aparentes en coordenadas
            pdy = (medyA1ll/n_pdy)


            n_pdx = int(n_pdx)
            n_pdy = int(n_pdy)
            d_px_a = []; d_py_a = []
            d_px_d = []; d_py_d = []
            for i in range(0,n_pdx+1):
                d_px_a.append(vx_ll+i*pdx)
                d_py_a.append(vy_ll)

            for i in range(0,n_pdy+1):
                d_px_d.append(vx_ll)
                d_py_d.append(vy_ll+i*pdy)

            # Creando puntos posibles
            ppx = []; ppy = []

            for i in range(0,len(d_px_a)):
                for j in range(0,len(d_px_d)):
                    ppx.append(d_px_a[i])
                    ppy.append(d_py_d[j]) 

            puntos_en_area_x.append(ppx); puntos_en_area_y.append(ppy)

        return puntos_en_area_x,puntos_en_area_y
    puntos_en_area_x,puntos_en_area_y = creando_puntos(1,num_zonas_en_campo+1,x_R,y_R,pph,vertices_x,vertices_y)

    def punto_en_poligono(x, y, poligono):
        """Comprueba si un punto se encuentra dentro de un polígono
            
           poligono - Lista de tuplas con los puntos que forman los vértices [(x1, x2), (x2, y2), ..., (xn, yn)]
        """
        i = 0
        j = len(poligono) - 1
        salida = False
        for i in range(len(poligono)):
            if (poligono[i][1] < y and poligono[j][1] >= y) or (poligono[j][1] < y and poligono[i][1] >= y):
                if poligono[i][0] + (y - poligono[i][1]) / (poligono[j][1] - poligono[i][1]) * (poligono[j][0] - poligono[i][0]) < x:
                    salida = not salida
            j = i
        return salida 

    def calculo_puntos_dentro(a,b,p_en_ax,p_en_ay,mark):
        vector_puntos_dentrox1 = []; vector_puntos_dentroy1 = []
        for i in range(a,b):
            puntos_dentrox = []; puntos_dentroy = []
            num_puntos = len(p_en_ax[i-1])
            x_point = p_en_ax[i-1]; y_point = p_en_ay[i-1]
            if mark == 0:
                pol = cpoligono[i] 
            else: pol =  cpoligono[0]
            for j in range (num_puntos):    
                aaa = punto_en_poligono(x_point[j], y_point[j], pol)
                if aaa == True:
                    puntos_dentrox.append(x_point[j]);puntos_dentroy.append(y_point[j])
            vector_puntos_dentrox1.append(puntos_dentrox);  
            vector_puntos_dentroy1.append(puntos_dentroy);
        return vector_puntos_dentrox1,vector_puntos_dentroy1

    vector_puntos_dentrox,vector_puntos_dentroy= calculo_puntos_dentro(1,num_zonas_en_campo+1
                      ,puntos_en_area_x,puntos_en_area_y,0)

    """
    # El que sirve"""

    ### Eliminando puntos (seleccionando)

    plt.figure(figsize=(10,10))
    def selec_point(points_in, puntos_in_lon, puntos_por_area):
          
        listado_numeros = [] # crea una lista para almacenar los numero rondón sin repetir.
        listado_numeros2 = [] # crea una lista para almacenar los numero rondón sin repetir.
        contador_rondas = 0 # almacena las veces que se agrega un numero a la lista.
        if (puntos_por_area/(len(points_in)))<0.7:
            puntos_a_eliminar = int((0.7-(puntos_por_area/(len(points_in))))*(len(points_in)))
            contador_rondas = 0 # almacena las veces que se agrega un numero a la lista.

            # se repite hasta que el tamaño de la lista no llegue a 5 (para el caso que solo quiera 5 numero).
            while contador_rondas < puntos_a_eliminar:
                numero_random = randint(0,(len(points_in))-1) # genera un numero random
                if numero_random in listado_numeros: # verifica si el número rondón ya se encuentra en la lista
                    pass
                else:
                    listado_numeros.append(numero_random) # agrega el número a la lista
                    contador_rondas = contador_rondas + 1 # suma a cada vuelta
            listado_numeros2 = [] # crea una lista para almacenar los numero rondón sin repetir.
            contador_rondas = 0 # almacena las veces que se agrega un numero a la lista.

            # se repite hasta que el tamaño de la lista no llegue a 5 (para el caso que solo quiera 5 numero).
            while contador_rondas < puntos_por_area:
                numero_random = randint(0,(len(points_in))-1) # genera un numero random
                if numero_random in listado_numeros or numero_random in listado_numeros2: # verifica si el número rondón ya se encuentra en la lista
                    pass
                else:
                    listado_numeros2.append(numero_random) # agrega el número a la lista
                    contador_rondas = contador_rondas + 1 # suma a cada vuelta    
        elif puntos_por_area >= (len(points_in)):
            puntos_a_eliminar = 0; puntos_por_area = (len(points_in))
        else: puntos_a_eliminar = 0
            
        # se repite hasta que el tamaño de la lista no llegue a 5 (para el caso que solo quiera 5 numero).
        while contador_rondas < puntos_por_area:
            numero_random = randint(0,(len(points_in))-1) # genera un numero random
            if numero_random in listado_numeros2: # verifica si el número rondón ya se encuentra en la lista
                pass
            else:
                listado_numeros2.append(numero_random) # agrega el número a la lista
                contador_rondas = contador_rondas + 1 # suma a cada vuelta
        p_d_lat = []; p_d_lon = []

        for i in listado_numeros2:
            p_d_lat.append(points_in[i])
            p_d_lon.append(puntos_in_lon[i])

        return p_d_lat,p_d_lon

    puntos_dentro_latitud = []; puntos_dentro_lontud = [] 
    ax = plt.axes()
    for i in range (len(vector_puntos_dentrox)):
        if vector_puntos_dentrox[i]==[]:
            p_d_lat = [] ; p_d_lon = []
        else:
            if (areasreales[i+1]<(puntos_por_area*10000/pph)):
                ppa = int(areasreales[i+1]/(10000/pph))
      
            else: ppa =  puntos_por_area
            p_d_lat,p_d_lon = selec_point(vector_puntos_dentroy[i], vector_puntos_dentrox[i], ppa)
        puntos_dentro_latitud.append(p_d_lat); puntos_dentro_lontud.append(p_d_lon)
        plt.plot(vertices_x[i+1], vertices_y[i+1], alpha=1, linewidth=2, solid_capstyle='round', zorder=2,label = "Area1")
        plt.plot(p_d_lon,p_d_lat,'o')
    plt.plot(vertices_x[0], vertices_y[0], alpha=1, linewidth=2, solid_capstyle='round', zorder=2,label = "Terreno") 
    # recreando areas

    ax.set_aspect('equal', adjustable='box')
    plt.savefig("/home/charry/Documents/programacion/trabajo de grado/web/ProjectWeb/WebApp/static/WebApp/img/cultivo_puntos.jpg", bbox_inches = 'tight')


    puntos_dentro_latitud1 = []; puntos_dentro_lontud1 = [] 
    for i in range (len(puntos_dentro_latitud)):
        for j in range (len(puntos_dentro_latitud[i])):
            puntos_dentro_latitud1.append((puntos_dentro_latitud[i][j]))
            puntos_dentro_lontud1.append((puntos_dentro_lontud[i][j]))

    ### Puntos
    # puntos_dentro_latitud1, puntos_dentro_lontud1

    areas_de_zonas = []
    for j in range (1,len(areasreales)):
        areas_de_zonas.append(areasreales[j])
    """# MARCADORES"""

    if dron == 1:
        #creando_puntos(1,num_zonas_en_campo+1,x_R,y_R,pph,vertices_x,vertices_y)
        marcadores_en_area_x,marcadores_en_area_y = creando_puntos(1,num_zonas_en_campo+1,x_R,y_R,num_markers*4,vertices_x,vertices_y)
        # calculo_puntos_dentro(1,num_zonas_en_campo+1,puntos_en_area_x,puntos_en_area_y,0)
        vector_marcadores_dentrox,vector_marcadores_dentroy= calculo_puntos_dentro(1,num_zonas_en_campo+1
                            ,marcadores_en_area_x,marcadores_en_area_y,0)

        puntos_markers_latitud = [ ]; puntos_markers_lontud = []
        for i in range (len(vector_marcadores_dentrox)):
            p_d_lat_mk,p_d_lon_mk = selec_point(vector_marcadores_dentroy[i], vector_marcadores_dentrox[i], num_markers)
            puntos_markers_latitud.append(p_d_lat_mk); puntos_markers_lontud.append(p_d_lon_mk)

        plt.figure(figsize=(15,15))
        ax = plt.axes()
        for i in range (len(vector_puntos_dentrox)):
            plt.plot(vertices_x[i+1], vertices_y[i+1], alpha=1, linewidth=2, solid_capstyle='round', zorder=2,label = "Area1")
        plt.plot(vertices_x[0], vertices_y[0], alpha=1, linewidth=2, solid_capstyle='round', zorder=2,label = "Terreno") 
        tam = 1/50000

        for i in range(len(puntos_markers_latitud)):
            estres_lat = puntos_markers_latitud[i]
            estres_lon = puntos_markers_lontud[i]
            for j in range(len(estres_lat)):
                markers(estres_lon[j]-tam, estres_lat[j]-tam, tam,ax)
        # recreando areas

        ax.set_aspect('equal', adjustable='box')
        plt.savefig("/home/charry/Documents/programacion/trabajo de grado/web/ProjectWeb/WebApp/static/WebApp/img/cultivo_marcadores.jpg", bbox_inches = 'tight')


        puntos_markers_latitud1 = []; puntos_markers_lontud1 = [] 
        for i in range (len(puntos_markers_latitud)):
            for j in range (len(puntos_markers_lontud[i])):
                puntos_markers_latitud1.append((puntos_markers_latitud[i][j]))
                puntos_markers_lontud1.append((puntos_markers_lontud[i][j]))

        ### Puntos
        # puntos_markers_latitud1, puntos_markers_lontud1

        # Tamaño del campo
        #Xmax; Ymax
        #areas_de_zonas
        return puntos_markers_latitud1, puntos_markers_lontud1, Xmax, Ymax  
    return puntos_dentro_latitud1, puntos_dentro_lontud1
